<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>River War</title>
    <link rel="manifest" href="manifest.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="River War">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Prevent browser gestures */
            user-select: none;
            -webkit-user-select: none;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            width: 100%;
            height: 100%;
            /* Responsive Scaling: Fit within viewport maintaining aspect ratio */
            max-width: 100vw;
            max-height: 100vh;
            aspect-ratio: 9/16; 
        }
        /* Mobile Landscape Warning */
        #landscape-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #fff;
            z-index: 100;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
        }
        @media screen and (orientation: landscape) and (max-width: 900px) {
            #landscape-warning {
                display: flex;
            }
        }
        canvas {
            display: block;
            background-color: #000;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            box-sizing: border-box;
            z-index: 10;
        }
        .hud-header {
            width: 100%;
            height: 15%; /* Responsive height */
            min-height: 100px;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.8), rgba(0,0,0,0));
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 20px 20px;
            box-sizing: border-box;
        }
        .left-hud {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 50%;
        }
        .right-hud {
            text-align: right;
            width: 50%;
        }
        .score-text {
            color: #fff;
            font-size: clamp(20px, 6vw, 40px); /* Larger minimum */
            font-weight: 800;
            letter-spacing: 2px;
            text-shadow: 2px 2px 0 #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .timer-text {
            color: #ffff00;
            font-size: clamp(18px, 5vw, 32px); /* Larger minimum */
            font-weight: bold;
            letter-spacing: 1px;
            text-shadow: 1px 1px 0 #000;
            margin-top: 5px;
            font-family: 'Courier New', Courier, monospace; 
        }
        #lives-display {
            display: flex;
            gap: 5px;
            padding: 5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
            width: fit-content;
            /* Scale for touch */
            transform-origin: top left;
            transform: scale(1.2); 
        }
        .life-icon {
            width: clamp(25px, 6vw, 35px);
            height: clamp(25px, 6vw, 35px);
            background-color: #ff0000; /* Red fill for Health */
            border: 2px solid #555;    /* Grey border */
            box-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
            margin-right: 5px;
        }
        .fuel-wrapper {
            width: 100%;
            max-width: 200px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        .fuel-label-text {
            color: #ddd;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 2px;
            text-shadow: 1px 1px 0 #000;
        }
        .fuel-container {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #fff;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.4);
        }
        #fuel-bar-fill {
            height: 100%;
            width: 100%;
            background-color: #00ffff; /* Cyan fill for Fuel */
            border-right: 2px solid #555; /* subtle border */
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transition: width 0.1s linear;
        }
        
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            z-index: 20;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        #game-over {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 4px 4px 0 #000;
            text-align: center;
            z-index: 15;
            background: rgba(0,0,0,0.85);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #fff;
            width: 80%;
            max-width: 400px;
        }
        .game-over-title {
            color: #ff3333;
            font-size: clamp(32px, 8vw, 64px);
            margin-bottom: 20px;
            text-transform: uppercase;
        }
        .final-score-container {
            font-size: clamp(20px, 5vw, 32px);
            margin-bottom: 30px;
            color: #fff;
        }
        .restart-btn {
            font-size: clamp(24px, 6vw, 36px); /* Larger text */
            padding: 20px 60px; /* Larger hit area */
            cursor: pointer;
            pointer-events: auto;
            background: #fff;
            border: none;
            border-radius: 12px;
            font-weight: bold;
            color: #111;
            text-transform: uppercase;
            transition: transform 0.1s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .restart-btn:active {
            transform: scale(0.95);
            background: #ddd;
        }
        
        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 32px;
            z-index: 18;
            cursor: pointer;
            font-weight: bold;
            letter-spacing: 2px;
            text-align: center;
        }
        
        #strait-warning {
            display: none;
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            color: #ff3333;
            font-size: clamp(24px, 5vw, 40px);
            font-weight: 900;
            text-shadow: 0 0 10px red;
            animation: blink 0.5s infinite;
            z-index: 12;
            pointer-events: none;
        }

        #boss-warning {
            display: none;
            position: absolute;
            top: 30%;
            width: 100%;
            text-align: center;
            color: #ff0000;
            font-size: clamp(28px, 6vw, 48px);
            font-weight: 900;
            text-shadow: 2px 2px 0 #000, 0 0 20px red;
            animation: blinkFast 0.2s infinite;
            z-index: 13;
            pointer-events: none;
            background: rgba(0,0,0,0.5);
            padding: 10px 0;
        }

        #low-fuel-warning {
            display: none;
            position: absolute;
            top: 50%;
            width: 100%;
            text-align: center;
            color: #ffaa00;
            font-size: clamp(30px, 7vw, 50px);
            font-weight: 900;
            text-shadow: 2px 2px 0 #000;
            animation: blink 0.5s infinite;
            z-index: 14;
            pointer-events: none;
        }
        
        #start-message {
            position: absolute;
            top: 35%;
            width: 100%;
            text-align: center;
            color: #00ff00;
            font-size: clamp(24px, 5vw, 36px);
            font-weight: bold;
            text-shadow: 0 0 5px #000;
            z-index: 12;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1s;
        }
        
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }
        @keyframes blinkFast { 0% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(1.1); } 100% { opacity: 1; transform: scale(1); } }
    </style>
</head>
<body>

<div id="game-container">
    <!-- Internal resolution fixed for logic, scaled by CSS -->
    <canvas id="gameCanvas" width="720" height="1280"></canvas>
    
    <div id="ui-layer">
        <div class="hud-header">
            <!-- Top-Left: Health & Fuel -->
            <div class="left-hud">
                <div id="lives-display">
                    <!-- Icons injected by JS -->
                </div>
                <div class="fuel-wrapper">
                    <div class="fuel-label-text">FUEL</div>
                    <div class="fuel-container">
                        <div id="fuel-bar-fill"></div>
                    </div>
                </div>
            </div>
            
            <!-- Top-Right: Score & Time -->
            <div class="right-hud">
                <div id="score-display" class="score-text">SCORE: 0</div>
                <div id="time-display" class="timer-text">TIME: 00:00</div>
            </div>
        </div>
        
        <div id="strait-warning">NARROW PASS</div>
        <div id="boss-warning">LARGE VESSEL DETECTED</div>
        <div id="low-fuel-warning">LOW FUEL</div>
        <div id="start-message">CALM FLIGHT</div>

        <div id="game-over">
            <div class="game-over-title">GAME OVER</div>
            <div class="final-score-container">
                SCORE: <span id="final-score">0</span>
            </div>
            <button class="restart-btn" onclick="location.reload()">RESTART</button>
        </div>
        <div id="landscape-warning">
            <div>Please rotate your device to Portrait mode to play</div>
        </div>
    </div>

    <div id="loading-screen">
    <div class="loader"></div>
    <div id="loading-text">Loading Assets...</div>
    <button id="reset-cache-btn" style="margin-top: 20px; padding: 10px 20px; background: #ff3333; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; z-index: 100;">FIX LOADING / RESET</button>
</div>

    <div id="start-overlay" onclick="startGameClick()">
        CLICK TO START
    </div>
</div>

<script>
/**
 * SENIOR GAME ENGINE ARCHITECTURE (Final Polish)
 * -------------------------------
 * - Asset Management: Robust Silent Fail-Safe (New Audio())
 * - Persistence: V2_TRAVEL_GAME
 * - UI: Responsive & English, Polished HUD
 * - Gameplay: Inertia, Tilt, Vibration, Clouds, Fuel Rebalance
 * - New Features: Straits, Handling Tweaks, Hitbox Refinement
 */

// --- CONFIGURATION ---
const CONFIG = {
    canvasWidth: 720,
    canvasHeight: 1280,
    // Reduced speed by 40% (was 500)
    playerSpeed: 300,
    // Smoothing factor for Lerp movement (Input Easing)
    playerSmoothing: 5.0, 
    scrollSpeed: 200,
    fuelDrainRate: 4, 
    maxFuel: 125, // Increased by 25%
    bulletSpeed: 800,
    enemyBulletSpeed: 400,
    initialSpawnRate: 2.0, 
    difficultyTimeScale: 60,
    storageKey: 'V2_TRAVEL_GAME'
};

// --- ASSET LIST ---
// Using relative paths to ensure compatibility with subdirectories on Vercel
const ASSETS = {
    Player: 'player_jet.png',
    Bullet: 'bullet.png',
    EnemyBullet: 'enemy_bullet.png',
    Enemy_Jet: 'enemy_jet.png',
    Enemy_Heli: 'enemy_heli.png',
    Enemy_Carrier: 'enemy_carrier.png',
    Explosion: 'explosion.png',
    FuelStation: 'fuelstation.png',
    FuelBar: 'fuelbar.png'
};

const AUDIO_ASSETS = {
    shot: 'click.mp3',
    explosion1: 'explosion_1.mp3',
    explosion2: 'explosion_2.mp3',
    refill: 'powerup.mp3',
    start: 'jump.mp3', 
    engine: 'engine.mp3'
};

// --- ASSET MANAGER ---
class AssetLoader {
    constructor() {
        this.images = {};
        this.audioObjects = {}; 
        this.totalCount = Object.keys(ASSETS).length + Object.keys(AUDIO_ASSETS).length;
        this.loadedCount = 0;
        
        // Audio Pool for high performance
        this.audioPool = {};
        this.poolSize = 5; // 5 clones per sound
    }

    loadAll(callback) {
        if (this.totalCount === 0) return callback();

        const checkDone = () => {
            this.loadedCount++;
            if (this.loadedCount >= this.totalCount) {
                this.initAudioPool(); // Initialize pool after loading
                callback();
            }
        };

        // Load Images
        for (let key in ASSETS) {
            const img = new Image();
            img.src = ASSETS[key];
            img.onload = checkDone;
            img.onerror = () => {
                this.images[key] = null; 
                checkDone();
            };
            this.images[key] = img;
        }

        // Load Audio
        for (let key in AUDIO_ASSETS) {
            const audio = new Audio();
            audio.src = AUDIO_ASSETS[key];
            audio.preload = 'auto';
            this.audioObjects[key] = audio;
            checkDone();
        }
    }

    initAudioPool() {
        for (let key in this.audioObjects) {
            this.audioPool[key] = [];
            const original = this.audioObjects[key];
            if (!original) continue;
            
            for(let i=0; i<this.poolSize; i++) {
                const clone = original.cloneNode();
                if (key === 'engine') {
                    clone.loop = true;
                    clone.volume = 0.3; // 30% volume for engine
                } else {
                    clone.volume = (key === 'shot') ? 0.2 : (key.startsWith('explosion') ? 0.8 : 0.5);
                }
                this.audioPool[key].push(clone);
            }
        }
    }

    getImage(key) {
        return this.images[key];
    }

    playAudio(key) {
        const pool = this.audioPool[key];
        if (!pool || pool.length === 0) return;
        
        // Find a free sound or recycle the oldest
        let sound = pool.find(s => s.paused || s.ended);
        
        // Special case for Engine: Use first instance if not playing
        if (key === 'engine') {
            sound = pool[0];
            if (!sound.paused) return; // Already playing
        } else if (!sound) {
            // If all busy, force reset the first one (Lag Fix)
            sound = pool[0];
        }
        
        try {
            if (key !== 'engine') sound.currentTime = 0;
            const promise = sound.play();
            if (promise !== undefined) {
                promise.catch(() => {});
            }
        } catch (e) {
            // Ignore
        }
    }

    stopAudio(key) {
        const pool = this.audioPool[key];
        if (!pool) return;
        pool.forEach(s => {
            s.pause();
            s.currentTime = 0;
        });
    }
}

// --- INPUT HANDLER ---
class InputHandler {
    constructor() {
        this.keys = {};
        window.addEventListener('keydown', e => this.keys[e.code] = true);
        window.addEventListener('keyup', e => this.keys[e.code] = false);
        
        window.addEventListener('touchstart', e => this.handleTouch(e));
        window.addEventListener('touchmove', e => this.handleTouch(e));
        window.addEventListener('touchend', () => { this.touchX = null; this.touchY = null; });
        
        this.touchX = null;
        this.touchY = null;
    }
    
    handleTouch(e) {
        e.preventDefault(); 
        const touch = e.touches[0];
        const rect = document.getElementById('gameCanvas').getBoundingClientRect();
        const scaleX = CONFIG.canvasWidth / rect.width;
        const scaleY = CONFIG.canvasHeight / rect.height;
        
        this.touchX = (touch.clientX - rect.left) * scaleX;
        this.touchY = (touch.clientY - rect.top) * scaleY;
    }

    isDown(code) {
        return !!this.keys[code];
    }
}

// --- GAME OBJECTS ---
class Entity {
    constructor(x, y, width, height, image) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.image = image;
        this.markedForDeletion = false;
        this.vx = 0;
        this.vy = 0;
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
    }

    draw(ctx) {
        if (this.image && this.image.complete && this.image.naturalHeight !== 0) {
            ctx.save();
            // Removed Multiply to restore original colors
            // ctx.globalCompositeOperation = 'multiply';
            ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
            ctx.restore();
        } 
        // 3. NO Red Fallbacks: Removed else block with fillRect
    }

    getBounds() {
        return { x: this.x + 5, y: this.y + 5, w: this.width - 10, h: this.height - 10 };
    }

    collidesWith(other) {
        const a = this.getBounds();
        const b = other.getBounds();
        return (a.x < b.x + b.w &&
                a.x + a.w > b.x &&
                a.y < b.y + b.h &&
                a.y + a.h > b.y);
    }
}

class Cloud extends Entity {
    constructor(game) {
        const x = Math.random() * CONFIG.canvasWidth;
        const y = -150;
        super(x, y, 200, 120, null); // Doubled size
        this.vy = CONFIG.scrollSpeed * 1.5; 
        this.scale = 0.5 + Math.random() * 1.0;
        this.opacity = 0.1 + Math.random() * 0.2;
    }
    
    update(dt) {
        this.y += this.vy * dt;
        if (this.y > CONFIG.canvasHeight + 100) this.markedForDeletion = true;
    }
    
    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.scale, this.scale);
        ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
        
        // HD Cloud (Fluffy) - Scaled drawing commands
        ctx.beginPath();
        ctx.arc(0, 0, 80, 0, Math.PI * 2);
        ctx.arc(60, -30, 90, 0, Math.PI * 2);
        ctx.arc(120, 0, 80, 0, Math.PI * 2);
        ctx.arc(60, 30, 70, 0, Math.PI * 2);
        ctx.fill();
        
        // Shadow for depth
        ctx.fillStyle = `rgba(200, 200, 220, ${this.opacity * 0.5})`;
        ctx.beginPath();
        ctx.arc(20, 20, 60, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
}

class Player extends Entity {
    constructor(game) {
        const img = game.assets.getImage('Player');
        super(CONFIG.canvasWidth / 2 - 64, CONFIG.canvasHeight - 300, 128, 128, img); // Doubled Size
        this.game = game;
        this.shootTimer = 0;
        this.shootCooldown = 0.25;
        this.angle = 0; 
        this.pitch = 0; 
        
        this.invincible = false;
        this.invincibleTimer = 0;
    }

    // Refined Collision Box (Shrunk by 35% -> 35% margin each side, very safe)
    getBounds() {
        const marginX = this.width * 0.35; 
        const marginY = this.height * 0.35;
        return { 
            x: this.x + marginX, 
            y: this.y + marginY, 
            w: this.width - marginX * 2, 
            h: this.height - marginY * 2 
        };
    }

    resetPosition() {
        this.x = CONFIG.canvasWidth / 2 - 64;
        this.y = CONFIG.canvasHeight - 300;
        this.vx = 0;
        this.vy = 0;
        this.angle = 0;
        this.pitch = 0;
    }

    setInvincible(duration) {
        this.invincible = true;
        this.invincibleTimer = duration;
    }

    update(dt) {
        if (this.invincible) {
            this.invincibleTimer -= dt;
            if (this.invincibleTimer <= 0) {
                this.invincible = false;
            }
        }

        // --- NEW MOVEMENT LOGIC: LERP (Damping) ---
        // Calculate Target Velocity based on Input
        let targetVx = 0;
        let targetVy = 0;

        if (this.game.input.isDown('ArrowLeft') || this.game.input.isDown('KeyA')) targetVx = -CONFIG.playerSpeed;
        if (this.game.input.isDown('ArrowRight') || this.game.input.isDown('KeyD')) targetVx = CONFIG.playerSpeed;
        if (this.game.input.isDown('ArrowUp') || this.game.input.isDown('KeyW')) targetVy = -CONFIG.playerSpeed;
        if (this.game.input.isDown('ArrowDown') || this.game.input.isDown('KeyS')) targetVy = CONFIG.playerSpeed;

        // Mobile Joystick Feel & Auto-Fire
        if (this.game.input.touchX !== null) {
            // Move towards touch point
            const dx = this.game.input.touchX - (this.x + this.width/2);
            const dy = this.game.input.touchY - (this.y + this.height/2);
            
            // Deadzone of 10px
            if (Math.abs(dx) > 10) targetVx = (dx > 0 ? 1 : -1) * CONFIG.playerSpeed;
            if (Math.abs(dy) > 10) targetVy = (dy > 0 ? 1 : -1) * CONFIG.playerSpeed;
            
            // Auto-Fire every 300ms
            if (this.shootTimer <= 0) {
                this.shoot();
                this.shootTimer = 0.3; // 300ms
            }
        }

        // Apply Linear Interpolation (Lerp) for smooth acceleration/deceleration
        // Formula: current = current + (target - current) * factor * dt
        const smoothing = CONFIG.playerSmoothing * dt;
        // Clamp smoothing to max 1.0 to prevent overshooting if dt is huge
        const factor = Math.min(smoothing, 1.0);
        
        this.vx += (targetVx - this.vx) * factor;
        this.vy += (targetVy - this.vy) * factor;

        // Calculate Visual Angles
        const targetAngle = (this.vx / CONFIG.playerSpeed) * 25 * (Math.PI / 180);
        this.angle += (targetAngle - this.angle) * 10 * dt;

        const targetPitch = (this.vy / CONFIG.playerSpeed) * 15 * (Math.PI / 180);
        this.pitch += (targetPitch - this.pitch) * 10 * dt;

        super.update(dt);

        if (this.y < 0) { this.y = 0; this.vy = 0; }
        if (this.y > CONFIG.canvasHeight - this.height) { this.y = CONFIG.canvasHeight - this.height; this.vy = 0; }
        
        if (this.shootTimer > 0) this.shootTimer -= dt;
        if (this.game.input.isDown('Space') && this.shootTimer <= 0) {
            this.shoot();
            this.shootTimer = this.shootCooldown;
        }
    }

    draw(ctx) {
        if (!this.image) return;
        
        if (this.invincible) {
            if (Math.floor(Date.now() / 100) % 2 === 0) return;
        }

        const vibrationX = (Math.random() - 0.5) * 2;
        const vibrationY = (Math.random() - 0.5) * 2;

        ctx.save();
        ctx.translate(this.x + this.width / 2 + vibrationX, this.y + this.height / 2 + vibrationY);
        ctx.rotate(this.angle + this.pitch);
        
        // Removed Multiply to restore original colors
        // ctx.globalCompositeOperation = 'multiply';
        ctx.drawImage(this.image, -this.width / 2, -this.height / 2, this.width, this.height);
        
        ctx.restore();
    }

    shoot() {
        this.game.bullets.push(new Bullet(this.game, this.x + this.width / 2 - 10, this.y, -1)); // Adjusted offset
        this.game.assets.playAudio('shot');
    }
}

class Bullet extends Entity {
    constructor(game, x, y, direction) { 
        // 1. Process the New Asset (enemy_bullet.png)
        // Enemy bullets (direction 1) use enemy_bullet.png
        const img = direction === -1 ? game.assets.getImage('Bullet') : game.assets.getImage('EnemyBullet');
        
        // Scale and Dimensions:
        // Player Bullet: 20x40
        // Enemy Bullet: 10x30 (as requested)
        const w = direction === -1 ? 20 : 10;
        const h = direction === -1 ? 40 : 30;
        
        super(x, y, w, h, img); 
        this.vy = (direction === -1 ? CONFIG.bulletSpeed : CONFIG.enemyBulletSpeed) * direction;
        this.isEnemy = direction === 1;
        this.game = game; 
    }

    update(dt) {
        super.update(dt);
        if (this.y < -50 || this.y > CONFIG.canvasHeight + 50) {
            this.markedForDeletion = true;
        }
    }

    draw(ctx) {
        // 2. ANNIHILATE THE RED SQUARES
        // If enemy_bullet.png fails to load, draw NOTHING.
        // ABSOLUTELY NO fillRect fallback for bullets.
        if (!this.image) return;
        
        ctx.save();
        if (this.isEnemy) {
            // Draw enemy bullet image
            // Ensure it faces down (image is likely pointing up or down, assume standard)
            // If the image is pointing UP by default, we might need to rotate it.
            // Assuming "Classic Military Rocket" points UP, let's rotate it 180 degrees if needed.
            // But let's stick to standard draw first to see if it works, usually sprites point UP.
            // If it points UP, and we want it to move DOWN, we should rotate it.
            
            ctx.translate(this.x + this.width/2, this.y + this.height/2);
            ctx.rotate(Math.PI); // Rotate 180 degrees to face down
            ctx.drawImage(this.image, -this.width/2, -this.height/2, this.width, this.height);
        } else {
            ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
        }
        ctx.restore();
    }
}

class FuelStation extends Entity {
    constructor(game, x, y) {
        super(x, y, 128, 128, game.assets.getImage('FuelStation')); // Doubled size
        this.game = game;
        this.vy = 0;
        this.health = 3; // Robust Stations
    }

    update(dt) {
        const speedMult = this.game.getSpeedMultiplier();
        this.y += CONFIG.scrollSpeed * speedMult * dt;
        if (this.y > CONFIG.canvasHeight + 100) this.markedForDeletion = true;
    }

    takeDamage() {
        this.health--;
        if (this.health <= 0) {
            this.markedForDeletion = true;
            this.game.explode(this.x + 64, this.y + 64, false, false, 'explosion2');
        } else {
            this.game.spawnSparkle(this.x + 64, this.y + 64);
        }
    }
}

class Enemy extends Entity {
    constructor(game, x, y, type) {
        let imgKey = 'Enemy_Jet';
        let w = 128, h = 128; // Doubled size
        let hp = 1;
        
        if (type === 'heli') { imgKey = 'Enemy_Heli'; }
        else if (type === 'boat') { imgKey = 'Enemy_Boat'; }
        else if (type === 'carrier') { imgKey = 'Enemy_Carrier'; w = 256; h = 512; hp = 8; } // Doubled size

        super(x, y, w, h, game.assets.getImage(imgKey));
        this.game = game;
        this.type = type;
        this.hp = hp;
        this.time = 0;
        this.startY = y;
        this.startX = x;
        
        this.flashTime = 0;
        
        // 2. Enemy Evolution: Jets shoot after 90s
        this.canShoot = (type === 'heli' || type === 'carrier');
        if (type === 'jet' && game.gameTime > 90) {
            this.canShoot = true;
        }
        
        this.shootTimer = Math.random() * 2 + 1; 

        // 1. Movement Axis Fix: Vertical Only (Downwards)
        this.vx = 0;
        
        // 4. Speed Sync: Constant speed, straight line
        if (this.type === 'jet') {
            this.vy = 300; // Fast
        } else if (this.type === 'heli') {
            this.vy = 150; // Medium
        } else if (this.type === 'boat') {
            this.vy = 0; // Moves with river scroll in update
        } else if (this.type === 'carrier') {
            this.vy = 80; // Slow
        }
    }

    update(dt) {
        this.time += dt;
        const speedMult = this.game.getSpeedMultiplier();

        // 2. No More Zig-Zags: Straight Line Logic
        // Removed Sine wave for Heli
        
        if (this.type === 'boat') {
             this.y += CONFIG.scrollSpeed * speedMult * dt; 
        }

        // Apply Velocity (Vertical)
        this.y += this.vy * speedMult * dt;
        
        // 3. Advanced Enemy AI (2-Minute Mark)
        // Evasive Maneuvers for Heli
        if (this.type === 'heli' && this.game.gameTime > 120) {
            // Sine wave pattern
            this.x += Math.sin(this.time * 3) * 150 * dt;
        }
        
        // --- DIFFICULTY LOGIC: No shooting in first 2 minutes (120s), EXCEPT BOSS ---
        // UPDATE: Jets shoot after 90s (Combat Phase)
        const combatPhase = this.game.gameTime > 90;
        
        if (this.canShoot && this.y > 0 && this.y < CONFIG.canvasHeight - 200) {
            // Firing Logic: Fire once when reaching top 25% of screen
            // 25% of 1280 is 320.
            if (this.y > 50 && this.y < 350 && this.shootTimer > 0) {
                 // Single shot logic managed by timer reset
            }

            if (this.type === 'carrier' || (this.type === 'jet' && combatPhase) || (this.type === 'heli' && this.game.gameTime > 120)) {
                this.shootTimer -= dt;
                if (this.shootTimer <= 0) {
                    let baseRate = this.type === 'carrier' ? 1.5 : 3.0;
                    this.shootTimer = (Math.random() * baseRate + 1) / speedMult; 
                    
                    // Fire bullet straight down
                    // Visuals: Enemy bullet handled in Bullet class via isEnemy flag
                    // Center the bullet: x + width/2 - bulletWidth/2 (12/2 = 6)
                    this.game.bullets.push(new Bullet(this.game, this.x + this.width/2 - 6, this.y + this.height, 1)); 
                }
            }
        }
        
        if (this.flashTime > 0) this.flashTime -= dt;
        
        // Destroy when off screen (Bottom)
        if (this.y > CONFIG.canvasHeight + 100) this.markedForDeletion = true;
    }
    
    draw(ctx) {
        if (!this.image) return;
        
        ctx.save();
        ctx.translate(this.x + this.width/2, this.y + this.height/2);
        
        // Enemy Orientation (Critical Fix): 180 degree vertical flip to face player
        if (this.type === 'jet' || this.type === 'heli' || this.type === 'carrier') {
            ctx.rotate(Math.PI);
        }
        
        // 2. ANNIHILATE Red Square on Carrier Hits:
        // Removed ctx.fillStyle = 'red' and ctx.fillRect(...) calls.
        // Instead, we use alpha modulation to create a subtle flash effect.
        if (this.flashTime > 0) {
             ctx.globalAlpha = 0.5; // Flash transparency
        }
        
        // Removed Multiply to restore original colors
        // ctx.globalCompositeOperation = 'multiply';
        ctx.drawImage(this.image, -this.width/2, -this.height/2, this.width, this.height);
        
        ctx.restore();
    }

    takeDamage() {
        this.hp--;
        this.flashTime = 0.1;
        
        if (this.hp <= 0) {
            this.markedForDeletion = true;
            const isBoss = this.type === 'carrier';
            this.game.explode(this.x + this.width/2, this.y + this.height/2, isBoss, false, isBoss ? 'explosion2' : 'explosion1');
            this.game.addScore(isBoss ? 500 : 100);
            if (isBoss) this.game.shakeScreen(20);
        } else {
            this.game.spawnSparkle(this.x + this.width/2, this.y + this.height/2);
        }
    }
}

class Explosion extends Entity {
    constructor(game, x, y, isBig, isSparkle = false) {
        const img = game.assets.getImage('Explosion');
        let size = isBig ? 256 : 128; // Doubled size
        if (isSparkle) size = 64; // Doubled size
        
        super(x - size/2, y - size/2, size, size, img);
        this.life = 0;
        this.maxLife = isSparkle ? 0.2 : 0.5;
        this.isSparkle = isSparkle;
    }

    update(dt) {
        this.life += dt;
        if (this.life >= this.maxLife) this.markedForDeletion = true;
    }

    draw(ctx) {
        // 1. ANNIHILATE Red Squares in Explosions:
        // Ensure ONLY the loaded explosion image is drawn. 
        // If no image is available, draw NOTHING.
        if (!this.image) return;
        
        ctx.globalAlpha = 1 - (this.life / this.maxLife);
        const scale = this.isSparkle ? 1 : (1 + (this.life / this.maxLife));
        
        ctx.save();
        ctx.translate(this.x + this.width/2, this.y + this.height/2);
        
        // Removed Multiply to restore original colors
        // ctx.globalCompositeOperation = 'multiply';
        ctx.drawImage(this.image, -this.width/2, -this.height/2, this.width, this.height);
        
        ctx.restore();
        
        ctx.globalAlpha = 1;
    }
}

// --- MAIN GAME ENGINE ---
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.input = new InputHandler();
        this.assets = new AssetLoader();
        
        this.lastTime = 0;
        this.step = 1 / 60;

        this.player = null;
        this.bullets = [];
        this.enemies = [];
        this.explosions = [];
        this.fuelStations = [];
        this.clouds = [];
        
        this.bgY = 0;
        this.score = 0;
        this.lives = 3;
        this.fuel = CONFIG.maxFuel;
        this.gameOver = false;
        this.paused = true; 
        
        this.shakeTime = 0;
        this.shakeMagnitude = 0;
        
        this.enemySpawnTimer = 0;
        this.fuelSpawnTimer = 10;
        this.cloudSpawnTimer = 0;
        
        this.gameTime = 0;
        this.difficultyMultiplier = 1;

        // Level Design: Straits
        this.straitTimer = 20; // First strait after 20s
        this.straitState = 'none'; // none, warning, narrowing, narrow, widening
        this.bankWidth = 0;
        this.targetBankWidth = 0;
        this.warningEl = document.getElementById('strait-warning');
        this.startMessageEl = document.getElementById('start-message');
        this.bossWarningEl = document.getElementById('boss-warning');
        this.bossTimer = 60; // First boss at 60s

        this.scoreEl = document.getElementById('score-display');
        this.timeEl = document.getElementById('time-display');
        this.livesEl = document.getElementById('lives-display');
        this.fuelBarFill = document.getElementById('fuel-bar-fill');
        this.gameOverScreen = document.getElementById('game-over');
        this.finalScoreEl = document.getElementById('final-score');
        
        localStorage.setItem(CONFIG.storageKey, Date.now().toString());

        this.assets.loadAll(() => {
            document.getElementById('loading-screen').style.display = 'none';
        });
        
        // Handle Resize
        window.addEventListener('resize', () => this.resize());
        this.resize();
    }

    resize() {
        const container = document.getElementById('game-container');
        const rect = container.getBoundingClientRect();
        
        // Update input handler scale factors if needed, 
        // but since we render to internal resolution and CSS scales it, 
        // InputHandler needs to know the ratio.
        
        // NOTE: The InputHandler calculates scale on touch event based on current rect,
        // so explicit resize logic here is mainly for the container style which is handled by CSS.
    }

    getSpeedMultiplier() {
        const t = this.gameTime;
        if (t < 30) return 1.0;
        if (t < 60) return 1.15;
        // After 60s: Increase by 10% compounding every 30 seconds.
        const periods = Math.floor((t - 60) / 30) + 1;
        return 1.15 * Math.pow(1.10, periods);
    }

    start() {
        this.paused = false;
        document.getElementById('start-overlay').style.display = 'none';
        
        // Audio Context usually needs user interaction to resume/start
        // This is handled by the click on start-overlay
        this.assets.playAudio('start');
        this.assets.playAudio('engine'); // Start Engine Loop
        
        this.init();
        this.loop(0);
    }

    init() {
        this.player = new Player(this);
        this.lives = 3;
        this.score = 0;
        this.fuel = CONFIG.maxFuel;
        this.gameOver = false;
        this.bullets = [];
        this.enemies = [];
        this.explosions = [];
        this.fuelStations = [];
        this.clouds = [];
        this.gameTime = 0;
        this.difficultyMultiplier = 1;
        
        this.straitTimer = 20;
        this.straitState = 'none';
        this.bankWidth = 0;
        this.targetBankWidth = 0;
        this.warningEl.style.display = 'none';
        
        this.bossTimer = 60;
        this.bossWarningEl.style.display = 'none';

        this.updateUI();
        
        // Show Calm Flight Message
        this.startMessageEl.style.opacity = 1;
        setTimeout(() => {
            this.startMessageEl.style.opacity = 0;
        }, 5000);
    }

    spawnLevelElements(dt) {
        // --- BOSS SPAWN LOGIC ---
        this.bossTimer -= dt;
        if (this.bossTimer <= 3 && this.bossTimer > 0) {
             this.bossWarningEl.style.display = 'block';
        } else if (this.bossTimer <= 0) {
             this.bossWarningEl.style.display = 'none';
             this.bossTimer = 60; // Reset for next boss
             
             // Spawn Boss (Top, centered)
             // Boss width is 256
             const safeWidth = CONFIG.canvasWidth - (this.bankWidth * 2) - 256;
             const spawnX = this.bankWidth + (safeWidth / 2); 
             this.enemies.push(new Enemy(this, spawnX, -300, 'carrier'));
        }

        this.enemySpawnTimer -= dt;
        if (this.enemySpawnTimer <= 0) {
            // Early Game (First 60s): Reduce spawn rate by increasing interval
            let spawnRateMultiplier = 1.0;
            if (this.gameTime < 60) spawnRateMultiplier = 1.25; // 25% slower spawning
            
            const currentSpawnRate = Math.max(0.5, (CONFIG.initialSpawnRate * spawnRateMultiplier) / (this.difficultyMultiplier * 0.8));
            this.enemySpawnTimer = currentSpawnRate;
            
            const r = Math.random();
            
            // 3. Narrow Area Spawn Boundaries (Fixed)
            const objectWidth = 128; // Enemy width
            
            // Explicit Calculation as requested:
            const riverX = this.bankWidth; // Left edge
            const riverWidth = CONFIG.canvasWidth - (this.bankWidth * 2);
            
            // Constrain the spawn x coordinate strictly between the current riverX (left edge) and (riverX + riverWidth - objectWidth) (right edge).
            // Ensure width is positive (safeWidth)
            const safeSpawnWidth = Math.max(0, riverWidth - objectWidth);
            const spawnX = riverX + Math.random() * safeSpawnWidth;
            
            const spawnY = -100;
            
            if (r < 0.4) {
                this.enemies.push(new Enemy(this, spawnX, spawnY, 'heli'));
            } else {
                this.enemies.push(new Enemy(this, spawnX, spawnY, 'jet'));
            }
        }

        this.fuelSpawnTimer -= dt;
        if (this.fuelSpawnTimer <= 0) {
            this.fuelSpawnTimer = 15; 
            
            // 3. Narrow Area Spawn Boundaries (Fixed) for Fuel Station
            const objectWidth = 128; // FuelStation width
            
            const riverX = this.bankWidth;
            const riverWidth = CONFIG.canvasWidth - (this.bankWidth * 2);
            
            const safeSpawnWidth = Math.max(0, riverWidth - objectWidth);
            const x = riverX + Math.random() * safeSpawnWidth;
            
            this.fuelStations.push(new FuelStation(this, x, -100));
        }
        
        this.cloudSpawnTimer -= dt;
        if (this.cloudSpawnTimer <= 0) {
            this.cloudSpawnTimer = Math.random() * 2 + 1;
            this.clouds.push(new Cloud(this));
        }
    }

    updateStraits(dt) {
        // State Machine for Straits
        if (this.straitState === 'none') {
            this.straitTimer -= dt;
            if (this.straitTimer <= 0) {
                this.straitState = 'warning';
                this.straitTimer = 3; // 3 seconds warning
                this.warningEl.style.display = 'block';
            }
        } else if (this.straitState === 'warning') {
            this.straitTimer -= dt;
            if (this.straitTimer <= 0) {
                this.straitState = 'narrowing';
                this.warningEl.style.display = 'none';
                this.targetBankWidth = CONFIG.canvasWidth * 0.3; // Narrow to 40% width total (30% banks each side)
            }
        } else if (this.straitState === 'narrowing') {
            // Smoothly increase bank width
            this.bankWidth += (this.targetBankWidth - this.bankWidth) * 0.5 * dt;
            if (Math.abs(this.targetBankWidth - this.bankWidth) < 5) {
                this.straitState = 'narrow';
                this.straitTimer = 15; // Hold narrow for 15s
            }
        } else if (this.straitState === 'narrow') {
            this.straitTimer -= dt;
            if (this.straitTimer <= 0) {
                this.straitState = 'widening';
                this.targetBankWidth = 0;
                // 3. Difficulty Scaling: Clear Skies (3s pause)
                this.enemySpawnTimer = 3.0; 
            }
        } else if (this.straitState === 'widening') {
            this.bankWidth += (this.targetBankWidth - this.bankWidth) * 0.5 * dt;
            if (this.bankWidth < 5) {
                this.bankWidth = 0;
                this.straitState = 'none';
                this.straitTimer = 20 + Math.random() * 20; // Random cooldown
            }
        }
    }

    shakeScreen(magnitude) {
        this.shakeTime = 0.5;
        this.shakeMagnitude = magnitude;
    }

    update(dt) {
        if (this.gameOver || this.paused) return;

        this.gameTime += dt;
        // Difficulty multiplier still affects speed/spawn, but firing is handled in Enemy update
        this.difficultyMultiplier = this.getSpeedMultiplier();

        this.fuel -= CONFIG.fuelDrainRate * dt;
        if (this.fuel <= 0) {
            this.fuel = 0;
            this.handlePlayerHit(true);
        }
        
        // Low Fuel Warning (< 25%)
        const lowFuelEl = document.getElementById('low-fuel-warning');
        if (this.fuel > 0 && this.fuel < 25) {
            lowFuelEl.style.display = 'block';
        } else {
            lowFuelEl.style.display = 'none';
        }

        this.updateUI();
        this.updateStraits(dt);

        if (this.shakeTime > 0) {
            this.shakeTime -= dt;
            const rx = (Math.random() - 0.5) * this.shakeMagnitude;
            const ry = (Math.random() - 0.5) * this.shakeMagnitude;
            this.ctx.setTransform(1, 0, 0, 1, rx, ry);
        } else {
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        this.bgY += CONFIG.scrollSpeed * this.difficultyMultiplier * dt;
        if (this.bgY >= CONFIG.canvasHeight) this.bgY -= CONFIG.canvasHeight; 
        
        this.player.update(dt);
        this.spawnLevelElements(dt);

        this.enemies.forEach(e => e.update(dt));
        this.enemies = this.enemies.filter(e => !e.markedForDeletion);
        this.bullets.forEach(b => b.update(dt));
        this.bullets = this.bullets.filter(b => !b.markedForDeletion);
        this.explosions.forEach(e => e.update(dt));
        this.explosions = this.explosions.filter(e => !e.markedForDeletion);
        this.fuelStations.forEach(e => e.update(dt));
        this.fuelStations = this.fuelStations.filter(e => !e.markedForDeletion);
        this.clouds.forEach(e => e.update(dt));
        this.clouds = this.clouds.filter(e => !e.markedForDeletion);

        this.checkCollisions();
    }

    checkCollisions() {
        if (this.player.invincible) return;

        // 1. Wall Collision (Include Dynamic Banks)
        // If player enters the bank area on left or right
        const bounds = this.player.getBounds();
        if (bounds.x <= this.bankWidth || bounds.x + bounds.w >= CONFIG.canvasWidth - this.bankWidth) {
            this.handlePlayerHit();
            return;
        }

        // 2. Bullets vs Enemies/Fuel (And Bullet vs Bullet)
        this.bullets.forEach(b => {
            if (b.markedForDeletion) return;

            // 3. Bullet Collision (Counter-Play)
            // Player Bullet vs Enemy Bullet
            if (!b.isEnemy) {
                this.bullets.forEach(otherB => {
                    if (otherB.isEnemy && !otherB.markedForDeletion) {
                        if (b.collidesWith(otherB)) {
                            b.markedForDeletion = true;
                            otherB.markedForDeletion = true;
                            this.spawnSparkle(b.x + b.width/2, b.y + b.height/2);
                            this.assets.playAudio('shot'); // Small sound for deflect
                        }
                    }
                });
            }

            if (b.isEnemy) return; 
            
            this.enemies.forEach(e => {
                if (b.markedForDeletion || e.markedForDeletion) return;
                if (b.collidesWith(e)) {
                    b.markedForDeletion = true; 
                    e.takeDamage();
                }
            });

            this.fuelStations.forEach(f => {
                if (b.markedForDeletion || f.markedForDeletion) return;
                if (b.collidesWith(f)) {
                    b.markedForDeletion = true;
                    f.takeDamage();
                }
            });
        });

        // 3. Enemy Bullets vs Player
        this.bullets.forEach(b => {
            if (!b.isEnemy) return;
            if (b.collidesWith(this.player)) {
                b.markedForDeletion = true;
                this.handlePlayerHit();
            }
        });

        // 4. Player vs Enemies
        this.enemies.forEach(e => {
            if (e.markedForDeletion) return;
            if (this.player.collidesWith(e)) {
                e.takeDamage();
                this.handlePlayerHit();
            }
        });

        // 5. Player vs Fuel Station
        this.fuelStations.forEach(f => {
            if (f.markedForDeletion) return;
            if (this.player.collidesWith(f)) {
                f.markedForDeletion = true;
                // Force refill to 100 regardless of station HP
                this.fuel = 100;
                this.assets.playAudio('refill');
                this.addScore(50);
            }
        });
    }

    handlePlayerHit(fuelEmpty = false) {
        this.shakeScreen(10);
        this.lives--;
        this.updateUI(); 
        this.explode(this.player.x + 64, this.player.y + 64, true, false, 'explosion1'); // Adjusted offset
        
        if (this.lives <= 0) {
            this.handleGameOver();
        } else {
            // Fuel Reset on Death: Player must start every life with a full tank (100)
            this.fuel = 100; 

            this.player.resetPosition();
            this.player.setInvincible(2); 
            this.assets.playAudio('start');
            
            // Reset Straits on death for fairness
            this.straitState = 'widening';
            this.targetBankWidth = 0;
            this.bankWidth = 0;
            this.warningEl.style.display = 'none';
        }
    }

    handleGameOver() {
        this.gameOver = true;
        this.assets.stopAudio('engine'); // Stop Engine Loop
        this.gameOverScreen.style.display = 'block';
        this.bossWarningEl.style.display = 'none';
        this.finalScoreEl.innerText = this.score;
        document.getElementById('ui-layer').style.pointerEvents = 'auto'; 
    }

    explode(x, y, isBig, isSparkle = false, soundName = 'explosion1') {
        this.explosions.push(new Explosion(this, x, y, isBig, isSparkle));
        if (!isSparkle) this.assets.playAudio(soundName);
    }

    spawnSparkle(x, y) {
        this.explosions.push(new Explosion(this, x, y, false, true));
    }

    addScore(points) {
        this.score += points;
        
        // 1. Life Reward System: +1 Life every 3000 points
        if (Math.floor(this.score / 3000) > Math.floor(this.lastLifeScore / 3000)) {
            this.lives++;
            this.assets.playAudio('refill'); // Sound effect
            // Visual feedback
            const feedback = document.createElement('div');
            feedback.innerText = "+1 LIFE";
            feedback.style.position = 'absolute';
            feedback.style.top = '50%';
            feedback.style.left = '50%';
            feedback.style.transform = 'translate(-50%, -50%)';
            feedback.style.color = '#00ff00';
            feedback.style.fontSize = '40px';
            feedback.style.fontWeight = 'bold';
            feedback.style.textShadow = '0 0 10px #000';
            feedback.style.zIndex = '20';
            feedback.style.animation = 'blink 1s forwards'; // Fade out
            document.getElementById('ui-layer').appendChild(feedback);
            setTimeout(() => feedback.remove(), 1000);
        }
        this.lastLifeScore = this.score;
    }

    updateUI() {
        this.scoreEl.innerText = `SCORE: ${this.score}`;
        
        // Format Time MM:SS
        const minutes = Math.floor(this.gameTime / 60);
        const seconds = Math.floor(this.gameTime % 60);
        const timeStr = `TIME: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        this.timeEl.innerText = timeStr;
        
        let livesHtml = '';
        for(let i=0; i<this.lives; i++) {
            livesHtml += '<div class="life-icon"></div>';
        }
        this.livesEl.innerHTML = livesHtml;
        
        this.fuelBarFill.style.width = `${(this.fuel / CONFIG.maxFuel) * 100}%`;
    }

    draw() {
        this.ctx.clearRect(0, 0, CONFIG.canvasWidth, CONFIG.canvasHeight);

        // 1. River Background (Modern HD Gradient & Organic Flow)
        
        // A. Depth Gradient (Left to Right: Dark -> Light -> Dark)
        const gradient = this.ctx.createLinearGradient(0, 0, CONFIG.canvasWidth, 0);
        gradient.addColorStop(0, '#004488');   // Deeper Blue Bank
        gradient.addColorStop(0.5, '#0099ff'); // Vibrant Center
        gradient.addColorStop(1, '#004488');   // Deeper Blue Bank
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, CONFIG.canvasWidth, CONFIG.canvasHeight);
        
        // B. Procedural Water Texture (Flow Lines)
        this.ctx.save();
        this.ctx.globalAlpha = 0.15;
        this.ctx.strokeStyle = '#aaddff'; // Light Blue/White lines
        this.ctx.lineWidth = 2;
        
        const flowOffset = this.gameTime * 150;
        this.ctx.beginPath();
        
        // Draw vertical flow lines with slight curve
        for (let x = 20; x < CONFIG.canvasWidth; x += 40) {
             // Offset Y based on X to stagger lines
             const offsetY = (x * 13) % 200;
             const lineY = (flowOffset + offsetY) % (CONFIG.canvasHeight + 200) - 200;
             
             this.ctx.moveTo(x, lineY);
             // Curve slightly
             this.ctx.quadraticCurveTo(x + Math.sin(this.gameTime + x)*10, lineY + 100, x, lineY + 200);
        }
        this.ctx.stroke();
        this.ctx.restore();
        
        // 2. Land Banks (Textured Forest Edge)
        if (this.bankWidth > 1) {
            // Base Green
            this.ctx.fillStyle = '#228822'; 
            this.ctx.fillRect(0, 0, this.bankWidth, CONFIG.canvasHeight); 
            this.ctx.fillRect(CONFIG.canvasWidth - this.bankWidth, 0, this.bankWidth, CONFIG.canvasHeight);
            
            // Texture: Simple Tree Tops (Circles)
            this.ctx.fillStyle = '#116611'; // Darker Green
            const treeSize = 40;
            const scrollY = this.bgY; 
            
            // Draw trees along the banks
            // Left Bank
            for (let y = -treeSize; y < CONFIG.canvasHeight + treeSize; y += treeSize) {
                const offset = (Math.sin(y * 0.1) * 10);
                this.ctx.beginPath();
                this.ctx.arc(this.bankWidth/2 + offset, y + (scrollY % treeSize), treeSize/1.5, 0, Math.PI*2);
                this.ctx.fill();
            }
            // Right Bank
            for (let y = -treeSize; y < CONFIG.canvasHeight + treeSize; y += treeSize) {
                const offset = (Math.sin(y * 0.1 + 2) * 10);
                this.ctx.beginPath();
                this.ctx.arc(CONFIG.canvasWidth - this.bankWidth/2 + offset, y + (scrollY % treeSize), treeSize/1.5, 0, Math.PI*2);
                this.ctx.fill();
            }
            
            // Coastline detail (simple line) matches river gradient
            this.ctx.fillStyle = '#0055aa'; 
            this.ctx.fillRect(this.bankWidth - 5, 0, 5, CONFIG.canvasHeight);
            this.ctx.fillRect(CONFIG.canvasWidth - this.bankWidth, 0, 5, CONFIG.canvasHeight);
        }

        // 3. Clouds (Background Layer)
        this.clouds.forEach(e => e.draw(this.ctx));

        // 4. Ground Objects
        this.fuelStations.forEach(e => e.draw(this.ctx));
        
        // 5. Air Objects
        this.enemies.forEach(e => e.draw(this.ctx));
        this.player.draw(this.ctx);
        this.bullets.forEach(b => b.draw(this.ctx));
        this.explosions.forEach(e => e.draw(this.ctx));
    }

    loop(timestamp) {
        if (!this.lastTime) this.lastTime = timestamp;
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;

        this.update(dt);
        this.draw();

        requestAnimationFrame((t) => this.loop(t));
    }
}

let gameInstance = null;
function startGameClick() {
    if (!gameInstance) gameInstance = new Game();
    gameInstance.start();
}

window.onload = () => {
    gameInstance = new Game();
    
    // Register Service Worker with forceful update
    // Using relative path for better compatibility
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('./sw.js')
            .then(reg => {
                console.log('Service Worker Registered', reg);
                reg.update(); // Check for updates immediately
            })
            .catch(err => console.log('Service Worker Failed', err));
            
        // Reload page when new service worker active
        navigator.serviceWorker.addEventListener('controllerchange', () => {
             console.log('New service worker active, reloading...');
             window.location.reload();
        });
    }

    // Manual Reset Handler
    document.getElementById('reset-cache-btn').addEventListener('click', () => {
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.getRegistrations().then(registrations => {
                for(let registration of registrations) {
                    registration.unregister();
                }
                alert('Cache cleared! Reloading...');
                window.location.reload();
            });
        } else {
            window.location.reload();
        }
    });
};

</script>
</body>
</html>
